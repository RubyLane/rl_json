<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Fri Nov 22 13:11:47 2019 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>json</title>

</head>
<body>

<h1 align="center">json</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PATHS">PATHS</a><br>
<a href="#TEMPLATES">TEMPLATES</a><br>
<a href="#EXCEPTIONS">EXCEPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">json - Parse
and manipulate JSON documents</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>package
require rl_json</b> ?<b>0.9.7</b>?</p>

<p style="margin-left:11%; margin-top: 1em"><b>json
exists</b> <i>jsonValue</i> ?<i>key ...</i>
?<i>modifier</i>?? <b><br>
json extract</b> <i>jsonValue</i> ?<i>key ...</i>
?<i>modifier</i>?? <b><br>
json foreach</b> <i>varlist1 jsonValue1</i> ?<i>varlist2
jsonValue2 ...</i>? <i>script</i> <b><br>
json get</b> <i>jsonValue</i> ?<i>key ...</i>
?<i>modifier</i>?? <b><br>
json get_typed</b> <i>jsonValue</i> ?<i>key ...</i>
?<i>modifier</i>?? <b><br>
json lmap</b> <i>varlist1 jsonValue1</i> ?<i>varlist2
jsonValue2 ...</i>? <i>script</i> <b><br>
json new</b> <i>type value</i> <b><br>
json normalize</b> <i>jsonValue</i> <b><br>
json pretty</b> <i>jsonValue</i> <b><br>
json set</b> <i>jsonVariableName</i> ?<i>key ...</i>?
<i>value</i> <b><br>
json template</b> <i>jsonValue</i> ?<i>dictionary</i>?
<b><br>
json unset</b> <i>jsonVariableName</i> ?<i>key ...</i>?
<b><br>
json isnull</b> <i>jsonValue key ...</i>? <b><br>
json type</b> <i>jsonValue key ...</i>?
______________________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package
adds a command <b>json</b> to the interpreter, and defines a
new Tcl_Obj type to store the parsed JSON document. The
<b>json</b> command directly manipulates values whose string
representation is valid JSON, in a similar way to how the
<b>dict</b> command directly manipulates values whose string
representation is a valid dictionary. It is similar to
<b>dict</b> in performance. <b><br>
json get</b> <i>jsonValue</i> ?<i>key ...</i>
?<i>modifier</i>??</p>

<p style="margin-left:22%;">Extract the value of a portion
of the <i>jsonValue</i>, returns the closest native Tcl type
(other than JSON) for the extracted portion. The <i>key
...</i> arguments are a path, as described in <b>PATHS</b>
below.</p>

<p style="margin-left:11%;"><b>json get_typed</b>
<i>jsonValue</i> ?<i>key ...</i> ?<i>modifier</i>??</p>

<p style="margin-left:22%;">Extract the value of a portion
of the <i>jsonValue</i>, returning a two element list: the
first element is the value that would be returned by <b>json
get</b> and the second element is the JSON type of the
extracted portion. The <i>key ...</i> arguments are a path,
as described in <b>PATHS</b> below.</p>

<p style="margin-left:11%;"><b>json extract</b>
<i>jsonValue</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Extract the value of a portion
of the <i>jsonValue</i>, returns the JSON fragment. The
<i>key ...</i> arguments are a path, as described in
<b>PATHS</b> below.</p>

<p style="margin-left:11%;"><b>json exists</b>
<i>jsonValue</i> ?<i>key ...</i> ?<i>modifier</i>??</p>

<p style="margin-left:22%;">Tests whether the supplied key
path (see <b>PATHS</b> below) and modifier resolve to
something that exists in <i>jsonValue</i> (i.e., that it can
be used with <b>json get</b> without error). Returns false
if the value named by the path <i>key ...</i> is null.</p>

<p style="margin-left:11%;"><b>json set</b>
<i>jsonVariableName</i> ?<i>key ...</i>? <i>value</i></p>

<p style="margin-left:22%;">Updates the JSON value stored
in the variable <i>jsonVariableName</i>, replacing the value
referenced by <i>key ...</i> (a path as described in
<b>PATHS</b> below) with the JSON value <i>value</i>.</p>

<p style="margin-left:11%;"><b>json unset</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Updates the JSON value stored
in the variable <i>jsonVariableName</i>, removing the value
referenced by <i>key ...</i>, a path as described in
<b>PATHS</b> below.</p>

<p style="margin-left:11%;"><b>json normalize</b>
<i>jsonValue</i></p>

<p style="margin-left:22%;">Return a
&ldquo;normalized&rdquo; version of the input
<i>jsonValue</i>, i.e., with all optional whitespace
trimmed.</p>

<p style="margin-left:11%;"><b>json template</b>
<i>jsonValue</i> ?<i>dictionary</i>?</p>

<p style="margin-left:22%;">Return a JSON value by
interpolating the values from <i>dictionary</i> into the
template, or from variables in the current scope if
<i>dictionary</i> is not supplied, in the manner described
in the section <b>TEMPLATES</b>.</p>

<p style="margin-left:11%;"><b>json new</b> <i>type
value</i></p>

<p style="margin-left:22%;">Return a JSON fragment of type
<i>type</i> and value <i>value</i>.</p>

<p style="margin-left:11%;"><b>json foreach</b> <i>varList1
jsonValue1</i> ?<i>varList2 jsonValue2 ...</i>?
<i>script</i></p>

<p style="margin-left:22%;">Evaluate <i>script</i> in a
loop in a similar way to the <b>foreach</b> command. In each
iteration, the values stored in the iterator variables in
each <i>varList</i> are the JSON fragments from
<i>jsonValue</i>. This command supports iterating over JSON
arrays and JSON objects. In the JSON object case, the
corresponding <i>varList</i> must be a two element list,
with the first specifiying the variable to hold the key and
the second the value. In the JSON array case, the rules are
the same as the <b>foreach</b> command.</p>

<p style="margin-left:11%;"><b>json lmap</b> <i>varList1
jsonValue1</i> ?<i>varList2 jsonValue2 ...</i>?
<i>script</i></p>

<p style="margin-left:22%;">Updates the JSON value stored
in the variable <i>jsonVariableName</i>, replacing the value
referenced by <i>key ...</i> (a path as described in
<b>PATHS</b> below) with the JSON value <i>value</i>. As for
<b>json foreach</b>, except that it is collecting; the
result from each evaluation of <i>script</i> is added to a
Tcl list and returned as the result of the <b>json lmap</b>
command. If the <i>script</i> results in a TCL_CONTINUE code
(e.g., the script does <b>continue</b>), that iteration is
skipped and no element is added to the result list. If it
results in TCL_BREAK (e.g., the script does <b>break</b>)
the iterations are stopped and the results accumulated so
far are returned.</p>

<p style="margin-left:11%;"><b>json isnull</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Return a boolean indicating
whether the named JSON value is null.</p>

<p style="margin-left:11%;"><b>json type</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Return the type of the named
JSON value, one of &quot;object&quot;, &quot;array&quot;,
&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;
or &quot;null&quot;.</p>

<p style="margin-left:11%;"><b>json pretty</b>
<i>jsonValue</i></p>

<p style="margin-left:22%;">Returns a pretty-printed string
representation of <i>jsonValue</i>. Useful for debugging or
inspecting the structure of JSON data.</p>

<h2>PATHS
<a name="PATHS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Several of the
commands (e.g., <b>json get</b>, <b>json exists</b>, <b>json
set</b> and <b>json unset</b>) accept a path specification
that names some subset of the supplied <i>jsonValue</i>. The
rules are similar to the equivalent concept in the
<b>dict</b> command, except that the paths used by
<b>json</b> allow indexing into JSON arrays by the integer
key (or a string matching the regex
&ldquo;^end(-[0-9]+)?$&rdquo;).</p>

<p style="margin-left:11%; margin-top: 1em">Some of the
commands also accept an optional modifier at the end of the
path, which is defined to be one of the following:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>?type</b></p></td>
<td width="4%"></td>
<td width="60%">


<p>Returns the type of the named fragment.</p></td>
<td width="18%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>?length</b></p>

<p style="margin-left:22%;">When the path refers to an
array, this returns the length of the array. When the path
refers to a string, this returns the number of characters in
the string. All other types throw an error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>?size</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Valid only for objects, returns the number of keys
defined in the object.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="7%">


<p><b>?keys</b></p></td>
<td width="4%"></td>
<td width="78%">


<p>Valid only for objects, returns a list of the keys in
the object.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">A literal value
that would match one of the above modifiers can be used as
the last element in the path by doubling the <b>?</b>. For
example:</p>

<p style="margin-left:22%; margin-top: 1em"><b>json get</b>
{ <br>
{ <br>
&quot;foo&quot;: { <br>
&quot;?size&quot;: &quot;quite big&quot; <br>
} <br>
} <br>
} foo ??size</p>

<p style="margin-left:11%; margin-top: 1em">Returns
&quot;quite big&quot;</p>

<h2>TEMPLATES
<a name="TEMPLATES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The command
<b>json template</b> generates JSON documents by
interpolating values into a template from a supplied
dictionary or variables in the current call frame, a
flexible mechanism for generating complex documents. The
templates are valid JSON documents containing string values
which match the regex &ldquo;^~[SNBJTL]:.+$&rdquo;. The
second character determines what the resulting type of the
substituted value will be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em"><b>S</b></p></td>
<td width="3%"></td>
<td width="80%">


<p style="margin-top: 1em">A string.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>N</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A number.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>B</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A boolean.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>J</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A JSON fragment.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>T</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A JSON template (substitutions are performed on the
inserted fragment).</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>L</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A literal. The resulting string is simply everything
from the fourth character onwards (this allows literal
strings to be included in the template that would otherwise
be interpreted as the substitutions above).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">None of the
first three characters for a template may be escaped.</p>

<p style="margin-left:11%; margin-top: 1em">The value
inserted is determined by the characters following the
substitution type prefix. When interpolating values from a
dictionary they name keys in the dictionary which hold the
values to interpolate. When interpolating from variables in
the current scope, they name scalar or array variables which
hold the values to interpolate. In either case if the named
key or variable doesn&rsquo;t exist, a JSON null is
interpolated in its place.</p>

<h2>EXCEPTIONS
<a name="EXCEPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Exceptions are
thrown when attempting to parse a string which isn&rsquo;t
valid JSON, or when a named path is invalid or doesn&rsquo;t
exist: <b><br>
RL JSON PARSE</b> <i>errormessage string charOfs</i></p>

<p style="margin-left:22%;">Thrown when trying to parse a
string that isn&rsquo;t valid JSON. The <i>string</i>
element contains the string that failed to parse, and the
first invalid character is at offset <i>charOfs</i> within
that string, using 0 based offsets.</p>

<p style="margin-left:11%;"><b>RL JSON BAD_PATH</b>
<i>path</i></p>

<p style="margin-left:22%;">Thrown when indexing into a
JSON value and the specified path isn&rsquo;t valid.
<i>path</i> is the left subset of the path up to first
element that caused the failure.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Produce a JSON
value from a template:</p>

<p style="margin-left:22%; margin-top: 1em"><b>json
template</b> { <br>
{ <br>
&quot;thing1&quot;: &quot;~S:val1&quot;, <br>
&quot;thing2&quot;: [&quot;a&quot;, &quot;~N:val2&quot;,
&quot;~S:val2&quot;, &quot;~B:val2&quot;, <br>
&quot;~S:val3&quot;, &quot;~L:~S:val1&quot;], <br>
&quot;subdoc1&quot;: &quot;~J:subdoc&quot;, <br>
&quot;subdoc2&quot;: &quot;~T:subdoc&quot; <br>
} <br>
} { <br>
val1 hello <br>
val2 1e6 <br>
subdoc { <br>
{ &quot;thing3&quot;: &quot;~S:val1&quot; } <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The result
(with formatting for readability):</p>

<p style="margin-left:22%; margin-top: 1em">{ <br>
&quot;thing1&quot;:&quot;hello&quot;, <br>

&quot;thing2&quot;:[&quot;a&quot;,1000000.0,&quot;1e6&quot;,true,null,&quot;~S:val1&quot;],
<br>

&quot;subdoc1&quot;:{&quot;thing3&quot;:&quot;~S:val1&quot;},
<br>
&quot;subdoc2&quot;:{&quot;thing3&quot;:&quot;hello&quot;}
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Incrementally
append an element to an array (similar to <b>dict
lappend</b>):</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:[]}} <br>
for {set i 0} {$i &lt; 4} {incr i} { <br>
json set doc foo end+1 [json new string &quot;elem:
$i&quot;] <br>
} <br>
# $doc is {&quot;foo&quot;:[&quot;elem 0&quot;,&quot;elem
1&quot;,&quot;elem 2&quot;,&quot;elem 3&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em">Similar to the
above, but prepend the elements instead:</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:[]}} <br>
for {set i 0} {$i &lt; 4} {incr i} { <br>
json set doc foo -1 [json new string &quot;elem: $i&quot;]
<br>
} <br>
# $doc is {&quot;foo&quot;:[&quot;elem 3&quot;,&quot;elem
2&quot;,&quot;elem 1&quot;,&quot;elem 0&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em">Trim an element
out of an array:</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]} <br>
json unset doc 1 <br>
# $doc is {[&quot;a&quot;,&quot;c&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em">Implicitly
create objects when setting a path that doesn&rsquo;t
exist:</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:1}} <br>
json set doc bar baz {&quot;hello, new obj&quot;} <br>
# $doc is
{&quot;foo&quot;:1,&quot;bar&quot;:{&quot;baz&quot;:&quot;hello,
new obj&quot;}}</p>

<p style="margin-left:11%; margin-top: 1em">Index through
objects and arrays (the path elements are unambiguous
because the json types they index into are known at resolve
time):</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:[&quot;a&quot;,{&quot;primes&quot;:[2,3,5,7,11,13,17,19]},&quot;c&quot;]}}
<br>
json get $doc foo 1 primes end-1 <br>
# returns 17</p>

<p style="margin-left:11%; margin-top: 1em">Handle a parse
error and display a helpful message indicating the character
that caused the failure:</p>

<p style="margin-left:22%; margin-top: 1em">try { <br>
json get { <br>
{ <br>
&quot;foo&quot;: { <br>
&quot;bar&quot;: true, <br>
} <br>
} <br>
} foo bar <br>
} trap {RL JSON PARSE} {errmsg options} { <br>
lassign [lrange [dict get $options -errorcode] 4 5] doc
char_ofs <br>
puts stderr &quot;$errmsg\n[string range $doc 0
$char_ofs-1](here --&gt;)[string range $doc $char_ofs
end]&quot; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Produces:</p>

<p style="margin-left:22%; margin-top: 1em">Error parsing
JSON value: Illegal character at offset 37</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>{</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>&quot;foo&quot;: {</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>&quot;bar&quot;: true,</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>(here --&gt;)}</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>}</p></td></tr>
</table>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">json, parsing,
formatting</p>
<hr>
</body>
</html>
